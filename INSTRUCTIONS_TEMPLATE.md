# Lab Instructions

## Lab Title
`<Insert Lab Name Here>`

## Version
`<v1.0 / Date>`

## Estimated Time
- `1.5 - 2 Hours`
    - `Setup 15 - 20 Minutes`
    - `RESTCONF 25-30 Minutes`
    - `NETCONF 20-35 Minutes`
    - `Comparison 10-15 Minutes`

---

## Learning Objectives
By the end of this lab, you will be able to:
- Objective 1 ‚Äì Read and interpret API documentation for the Catalyst 8k to identify valid RESTCONF endpoints.
- Objective 2 ‚Äì Use Python‚Äôs Requests library to interact with RESTCONF APIs, retrieving structured system/platform information such as make, model, and firmware version.
- Objective 3 ‚Äì Explain the role of YANG models in network programmability, and when they are required for API queries.
- Install and use the ncclient Python library to interact with NETCONF APIs on the Catalyst 8k device.
- Perform the same API call (system/platform information) with NETCONF and compare the results with RESTCONF output.
- Differentiate RESTCONF vs. NETCONF in terms of API style (REST vs. RPC/XML), data formats (JSON vs. XML), and use cases in network automation.

These objectives build foundational skills for aspiring **network engineers** and **infrastructure specialists**.

---

## Tools & Technologies
You will use:
- Editor/Runtime
    - Visual Studio Code + Dev Containers extension
    - Docker Desktop (Windows/macOS; WSL2 enabled on Windows)
    - Git & GitHub Classroom repository
- Language & Libraries (preinstalled in container)
    - Python 3.x
    - requests (Python library for HTTP/REST API calls)
    - json (built-in Python library for parsing RESTCONF output)
    - pprint (built-in Python library for pretty-printing responses)
    - ncclient (Python library for interacting with NETCONF APIs)
    - xmltodict (Python helper library to make XML NETCONF output easier to read ‚Äî optional but included in the container)
- API Tools
    - Postman (graphical API client; optional but helpful for exploring RESTCONF endpoints before coding)
    - cURL (command-line API client, can be used to verify RESTCONF endpoints manually)
    - Cisco DevNet Always-On Sandbox: Cisco Catalyst 8k Virtual Device
        - RESTCONF endpoint
        - NETCONF endpoint
- Command Line
    - Bash (WSL, macOS, or inside the devcontainer)

---

## Prerequisites
Before starting, make sure you:
- Navigate Linux and run Python scripts from the terminal
- Use basic Bash commands inside a dev container
- Recall Cisco IOS basics (e.g., show version, device models, firmware)
- Write and run simple Python scripts using functions and imports
- Work with JSON data and pretty-print results
- Understand basic API concepts (endpoints, GET vs POST, documentation)
- Use cURL or Postman to explore APIs
- Know that RESTCONF uses HTTP+JSON and NETCONF uses XML/RPC, sometimes defined by YANG models

---

## Deliverables
To receive credit, you must Commit and push the following to your Classroom repo:
- Source Code (in `src/`)
    - `src/restconf_system_info.py`
    
    Uses requests to call the Catalyst 8k RESTCONF endpoint, retrieves system/platform information (model, version, etc.), and prints results.

    - `src/netconf_system_info.py`
    
    Uses `ncclient` to call the Catalyst 8k NETCONF endpoint, retrieves the same system/platform information, and prints results.
    
    - `src/compare_outputs.py`
    
    Runs both RESTCONF and NETCONF calls, prints a side-by-side or sequential comparison, and notes key differences (JSON vs XML).

- Data Artifacts (in `data/`)
    - `data/raw/restconf_system.json`
    
    Raw RESTCONF response body saved from the device.
    
    - `data/raw/netconf_system.xml`
    
    Raw NETCONF response body saved from the device.
    
    - `data/reports/system_report.txt`
    
    Human-readable summary showing hostname, model, firmware version, and API method used (RESTCONF/NETCONF).

- Logs (in `logs/`)

    - `logs/restconf_system_info.log`
    
    Contains LAB5_START / LAB5_END, DEVCONTAINER_OK, PKG_OK: requests, CONNECT_OK: RESTCONF, CMD=GET system, RAW_SAVED=restconf_system.json.
    
    - `logs/netconf_system_info.log`
    
    Contains LAB5_START / LAB5_END, DEVCONTAINER_OK, PKG_OK: ncclient, CONNECT_OK: NETCONF, RPC=system info, RAW_SAVED=netconf_system.xml.
    
    - `logs/compare_outputs.log`
    
    Shows PARSE_OK for both JSON and XML, COMPARE_OK fields matched (model/version), and REPORT_SAVED=system_report.txt.
    
    - `logs/devcontainer_health.log (auto-generated by container)`
    
    Contains LAB5_HEALTH_START/END, DNS_OK, NET_OK, PKG_OK name=requests, PKG_OK name=ncclient, overall=True.
    
    - `logs/DEVCONTAINER_STATUS.txt` (auto-generated banner)
    
    Shows status with Overall status: READY.

> ‚ö†Ô∏è **Important:** No log file = no points, even if your code ‚Äúworked.‚Äù The grader only checks for log entries.

---

## Overview
In this lab, you‚Äôll take the leap from calling simple public APIs to working directly with network device APIs. Cisco‚Äôs Catalyst 8000v router in the DevNet Always-On Sandbox will serve as your target, exposing two modern interfaces for network programmability: **RESTCONF** and **NETCONF**.

You‚Äôll begin by reviewing the API documentation for the Catalyst device, then use Python‚Äôs `requests` library to call a RESTCONF endpoint and retrieve system or platform details such as device model and firmware version. This will feel familiar from your previous work with public APIs, but now you‚Äôre interacting with a real network device.

Next, you‚Äôll pivot to **NETCONF**, a protocol that communicates with network devices using XML and RPC (remote procedure calls). You‚Äôll use the Python `ncclient` library to make the equivalent request and examine the response format. Along the way, you‚Äôll learn when YANG models are required and why they‚Äôre important for defining device capabilities.

By the end of this lab, you will have performed the same query two different ways‚ÄîRESTCONF with JSON and NETCONF with XML‚Äîand compared the results. This side-by-side experience will give you a clear understanding of how network APIs differ from the public web APIs you‚Äôve worked with so far, and how they fit into modern automation workflows. 

üí° **Why this matters:** Modern networks cannot be managed manually at scale. Automation skills give you an edge as a job candidate and make you more effective in real-world environments.  

---

## Instructions

Follow these steps in order:

### Step 1 ‚Äì Clone the Repository
```bash
git clone <repo-url>
cd <repo-name>
```
- Confirm you see src/, data/, and logs/ directories.
> LOG REQUIREMENT: [STEP 1] Repo Cloned

### Step 2 ‚Äì Open a Dev Container
1. Launch VS Code
2. Select "Reopen in Container"
3. Wait for dependencies to install
NOTE: This can take a few minutes on first load

> LOG REQUIREMENT: [STEP 2] Dev Container Started


### Step 3 ‚Äì Access the Cisco DevNet Always-On Sandbox and confirm device details
1. Go to the Cisco DevNet Always-On Sandbox for the Catalyst 8000v.
2. Locate the system hostname/IP, RESTCONF port, and NETCONF port.
3. Confirm you can reach the device by pinging it from the dev container.

> LOG REQUIREMENT: [STEP 3] Sandbox Reachable

### Step 4 ‚Äì Review Catalyst 8k API documentation
1. Open the RESTCONF and NETCONF documentation for Catalyst 8k.
2. Identify the endpoint (for RESTCONF) and the equivalent RPC (for NETCONF) to retrieve system/platform information (make, model, version).
3. Take note of required authentication (username/password).

> LOG REQUIREMENT: [STEP 4] API Documentation Reviewed


### Step 5 ‚Äì Use Python requests to call the RESTCONF API for system/platform info
1. Write a script (src/restconf_system_info.py) using requests.
2. Authenticate to the Catalyst device, send a GET request to the RESTCONF endpoint.
3. Parse and pretty-print the JSON response.
4. Save the raw JSON to data/raw/restconf_system.json.

> LOG REQUIREMENT: [STEP 5] RESTCONF Call Success

### Step 6 ‚Äì Save RESTCONF output and log results
1. Verify JSON file is saved in the correct directory.
2. Insert log lines in `logs/restconf_system_info.log` showing RESTCONF connection, API call, and saved file path.

### Step 7 ‚Äì Use Python ncclient to call the NETCONF API for the same system/platform info
1. Write a script (src/netconf_system_info.py) using ncclient.
2. Establish a NETCONF session with the Catalyst device.
3. Issue the RPC for system/platform info.
4. Print and save the raw XML to data/raw/netconf_system.xml.

> LOG REQUIREMENT: [STEP 7] NETCONF Call Success

### Step 8 ‚Äì Save NETCONF output and log results
1. Verify XML file is saved in the correct directory.
2. Insert log lines in logs/netconf_system_info.log showing NETCONF connection, RPC issued, and saved file path.

### Step 9 ‚Äì Compare RESTCONF vs NETCONF outputs
1. Write a script (`src/compare_outputs.py`).
2. Load the saved JSON (RESTCONF) and XML (NETCONF).
3. Parse both into human-readable form.
4. Print a comparison showing model and firmware from both methods.
5. Log results in `logs/compare_outputs.log`.

> LOG REQUIREMENT: [STEP 9] Comparison Complete

### Step 10 ‚Äì Generate final report and push deliverables to GitHub
1. Create data/reports/system_report.txt summarizing:
    - Hostname
    - Model
    - Firmware version
    - API methods used (RESTCONF/NETCONF)
2. Commit and push all changes to your GitHub Classroom repo.
3. Verify logs, data, and src files are all in the correct directories.

> LOG REQUIREMENT: [STEP 10] Deliverables Pushed

## Troubleshooting
1. Dev Container Missing Libraries
    - Symptom: `ModuleNotFoundError: No module named 'ncclient'` or `requests` not found.
    - Fix: Ensure you opened the repo in the devcontainer. Run `pip list` inside the container to confirm. If missing, reinstall with:
```bash
pip install -r requirements.txt
```

2. RESTCONF Call Fails
    - Symptom: `401 Unauthorized` or timeout when calling the RESTCONF endpoint.
    - Fix: Double-check sandbox username/password. Ensure you‚Äôre hitting the correct RESTCONF port from the sandbox page.

3. NETCONF Session Error
    - Symptom: `SSHError`, `EOFError`, or `SessionCloseError`.
    - Fix: Verify you‚Äôre using the correct NETCONF port (usually 830). Make sure your credentials are correct. Keep the NETCONF manager context open until after your RPC finishes.

4. Messy XML Output
    - Symptom: NETCONF response prints a huge block of unformatted XML.
    - Fix: Use `xml.dom.minidom` or `xmltodict` to pretty-print or convert XML into Python dictionaries.

5. Wrong Endpoint Path (RESTCONF)
    - Symptom: `404 Not Found` or empty JSON returned.
    - Fix: Confirm the exact endpoint path from Catalyst API documentation. RESTCONF URLs are case-sensitive and must match the YANG model schema.

6. File Writing Errors
    - Symptom: `FileNotFoundError` or output doesn‚Äôt appear in `data/`.
    - Fix: Save to the correct relative path:
```bash
with open("data/raw/restconf_system.json", "w") as f:
    f.write(response.text)
```

7. Autograder Deduction Even If Scripts Work Locally
    - Symptom: Lost points despite working code.
    - Fix: Check that file names and paths match the deliverables exactly (`restconf_system_info.py` ‚â† `RestconfSystemInfo.py`). Ensure you committed and pushed, not just saved locally.

## :light_bulb: Pro Tips
- Use Context Managers for NETCONF
```python
from ncclient import manager
with manager.connect(host=HOST, port=830, username=USER, password=PASS, hostkey_verify=False) as m:
    reply = m.get(filter=("subtree", "<system/>"))
```

- Pretty-Print XML and JSON
```python
import xml.dom.minidom, json, pprint
print(xml.dom.minidom.parseString(reply.xml).toprettyxml())
pprint.pprint(json.loads(restconf_response.text))
```

- Sanity-Check Fields

Always confirm your JSON/XML contains `model` and `version` fields before writing your report.

- Don‚Äôt Hardcode Credentials

Use `input()` and `getpass.getpass()` instead of storing usernames/passwords in your code.

- Compare Outputs Logically

Think in data structures, not just strings ‚Äî extract the fields you need and compare values rather than entire blobs of XML vs JSON.

- Keep Logs Consistent

Insert log markers (`LAB5_START`, `RESTCONF_OK`, `NETCONF_OK`, `REPORT_SAVED`) exactly where instructions specify. Autograder checks for these tokens.

## Grading and Points Breakdown

| Step | Requirement                               | Points |
|------|-------------------------------------------|--------|
| 1    | Repo cloned and structure verified        | 5      |
| 2    | Dev Container opened, dependencies OK     | 5      |
| 3    | Sandbox reachable (ping/credentials set)  | 5      |
| 4    | API documentation reviewed and noted      | 5      |
| 5    | RESTCONF script runs, retrieves JSON      | 10     |
| 6    | RESTCONF output saved + log entries OK    | 5      |
| 7    | NETCONF script runs, retrieves XML        | 10     |
| 8    | NETCONF output saved + log entries OK     | 5      |
| 9    | Compare script runs, JSON vs XML matched  | 10     |
| 10   | System report generated in correct format | 10     |
| 10   | All deliverables pushed, logs complete    | 5      |
|      | **Total**                                 | **75** |


## Submission Checklist
:green_checkmark: Repo Cloned
:green_checkmark: Dev Container Opened
