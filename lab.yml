# ==========================================
# Course: Software Defined Networking
# Module: RESTCONF vs NETCONF on Catalyst 8k
# Purpose: Hands on activity for interacting with network device APIs
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 5 — RESTCONF vs NETCONF on Catalyst 8k"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 5
time_estimate: "1.5–2 hours"
#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "Introduction to Network Device APIs"
    content: |
      Modern network devices expose programmable interfaces via RESTCONF and NETCONF, allowing
      automation tools to interact with device configurations and state data. This lab explores
      both protocols on a Cisco Catalyst 8000v device, comparing their usage and outputs.

  - title: "What is RESTCONF?"
    content: |
      RESTCONF is a REST-like protocol that provides a programmatic interface for accessing
      data defined in YANG, using HTTP methods. It typically returns data in JSON formats. RESTCONF
      is stateless and leverages standard HTTP features like authentication, caching, and error handling. You
      will use Python's `requests` library to interact with RESTCONF endpoints but can also use tools like Postman or curl.

      RESTCONF is defined in RFC 8040 and listens on HTTP/HTTPS ports (often 443). To enable RESTCONF on a Cisco device,
      you typically use the `restconf` command in global configuration mode as shown below:

    code_block:
      language: "bash"
      code: |
        router(config)# restconf
        router(config)# end
    code_notes: >
      Notes about the code block example.

  - title: "What is NETCONF?"
    content: |
      NETCONF is a network management protocol that provides mechanisms to install, manipulate,
      and delete the configuration of network devices. It uses XML for data encoding and operates
      over SSH. NETCONF is stateful and supports transactions, making it suitable for complex
      configuration tasks. You will use Python's `ncclient` library to interact with NETCONF, but
      tools like `netconf-console` can also be used.

      NETCONF is defined in RFC 6241 and typically listens on port 830. To enable NETCONF on a Cisco device,
      you usually need to ensure SSH is enabled and the device is configured to accept NETCONF sessions.
      On many Cisco devices, NETCONF is enabled by default when SSH is active. However, if you need to explicitly
      enable it, you can use the following commands:

    code_block:
      language: "bash"
      code: |
        router(config)# netconf-yang
        router(config)# end

  - title: "Comparing RESTCONF and NETCONF"
    content: |
      Both RESTCONF and NETCONF are powerful protocols for network device management, each with its
      own strengths. RESTCONF's use of HTTP and JSON makes it more accessible for web developers
      and easier to integrate with modern web services. In contrast, NETCONF's XML-based approach
      and support for transactions make it more suitable for complex configuration tasks in traditional
      network management scenarios.

      In this lab, you will interact with both protocols on a Cisco Catalyst 8000v device to retrieve
      system information, compare the outputs, and understand how YANG models influence both interfaces.

      RESTCONF is more suitable for web-based applications and simpler tasks, while NETCONF is often preferred for
      complex configurations and environments where transactional integrity is crucial. Device telemetry streaming
      is another area where NETCONF excels, as it can efficiently handle large volumes of data and provide real-time updates.

  - title: "What is YANG?"
    content: |
      YANG is a data modeling language used to define the structure of data that can be managed
      by network devices. It provides a way to model configuration and state data in a hierarchical
      manner, making it easier to understand and manipulate. YANG models are used by both RESTCONF
      and NETCONF to define the data that can be accessed or modified.

      In RESTCONF, YANG models are typically exposed as RESTful APIs, allowing clients to interact
      with the data using standard HTTP methods. In NETCONF, YANG models are used to define the
      XML-based RPC messages that are exchanged between clients and devices.

      Understanding YANG is crucial for working with both RESTCONF and NETCONF, as it provides
      the foundation for the data structures and operations that these protocols support.

      An example of YANG model snippet for system information might look like this:

    code_block:
      language: "yang"
      code: |
        module system {
          namespace "http://example.com/system";
          prefix sys;

          container system {
            leaf hostname {
              type string;
            }
            leaf version {
              type string;
            }
          }
        }
    code_notes: |
      This YANG model defines a `system` container with `hostname` and `version` leaves, which can be accessed via both RESTCONF and NETCONF 
      interfaces by referencing the appropriate paths or RPCs.  You can build the paths for RESTCONF based on the YANG model structure, and 
      for NETCONF, you can construct RPCs that correspond to the defined data nodes. To construct the RESTCONF path for the `system` container, you would typically use a URL like:

      `https://<device-ip>/restconf/data/system:system`

      To construct a NETCONF RPC to retrieve the same information, you would create an XML payload like:

      ```xml
      <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
        <get>
          <filter>
            <system xmlns="http://example.com/system">
              <hostname/>
              <version/>
            </system>
          </filter>
        </get>
      </rpc>
      ```

  - title: "Cisco Catalyst 8k API Docs"
    content: |
      Cisco provides comprehensive API documentation for the Catalyst 8000 series, including
      RESTCONF and NETCONF interfaces. You can find the documentation at the following link:

      [Cisco Catalyst 8000 Series API Documentation](https://developer.cisco.com/docs/catalyst-8000/)

      This documentation includes details on available YANG models, RESTCONF endpoints, and
      NETCONF RPCs, along with examples and usage guidelines.

      This documentation is an essential resource for understanding how to interact with the
      Catalyst 8000 series devices using their APIs.

  - title: "Creating a RESTCONF Request with Python `requests`"
    content: |
      To create a RESTCONF request using Python's `requests` library, you need to set up the
      appropriate headers, authentication, and the URL for the RESTCONF endpoint. Below is an
      example of how to perform a GET request to retrieve system information from a Cisco
      Catalyst 8000v device.

    code_block:
      language: "python"
      code: |
        import requests
        from requests.auth import HTTPBasicAuth
        import json

        # Device details
        device_ip = "sandbox-iosxe-latest-1.cisco.com"
        restconf_port = 443
        username = "developer"
        password = "C1sco12345"

        # RESTCONF endpoint for system information
        url = f"https://{device_ip}:{restconf_port}/restconf/data/Cisco-IOS-XE-native:native/system"

        # Headers for RESTCONF
        headers = {
            "Accept": "application/yang-data+json",
            "Content-Type": "application/yang-data+json"
        }

        # Make the GET request
        response = requests.get(url, auth=HTTPBasicAuth(username, password), headers=headers, verify=False)

        # Check the response status
        if response.status_code == 200:
            system_info = response.json()
            print(json.dumps(system_info, indent=2))
        else:
            print(f"Error: {response.status_code} - {response.text}")
    code_notes: |
      In this example, replace `device_ip`, `username`, and `password` with your actual device
      details. The `verify=False` parameter is used to ignore SSL certificate warnings, which
      is common in lab environments. The response is checked for a successful status code (200),
      and if successful, the JSON response is printed in a formatted manner.

  - title: "Creating a NETCONF Request with Python `ncclient`"
    content: |
      To create a NETCONF request using Python's `ncclient` library, you need to establish
      a connection to the device and then send an RPC to retrieve the desired information.
      Below is an example of how to perform a GET request to retrieve system information
      from a Cisco Catalyst 8000v device.

    code_block:
      language: "python"
      code: |
        from ncclient import manager
        import xml.etree.ElementTree as ET

        # Device details
        device_ip = "sandbox-iosxe-latest-1.cisco.com"
        netconf_port = 830
        username = "developer"
        password = "C1sco12345"

        # NETCONF filter for system information
        filter = """
        <filter>
          <native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
            <system>
            </system>
          </native>
        </filter>
        """

        # Establish NETCONF connection
        with manager.connect(host=device_ip, port=netconf_port, username=username, password=password, hostkey_verify=False) as m:
            # Send the NETCONF RPC
            response = m.get(filter)

            # Parse and print the XML response
            xml_response = ET.fromstring(response.xml)
            print(ET.tostring(xml_response, encoding='unicode', method='xml'))
    code_notes: |
      In this example, replace `device_ip`, `username`, and `password` with your actual device
      details. The `hostkey_verify=False` parameter is used to ignore SSH host key verification,
      which is common in lab environments. The response is parsed as XML and printed in a
      readable format.

#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================
# LAB 5 — RESTCONF & NETCONF on Catalyst 8k
# Software Defined Networking • Florida State College at Jacksonville
# Worth 75 points

# OBJECTIVES
objectives:
  - "Call at least two RESTCONF endpoints and two NETCONF RPCs on a Catalyst 8k sandbox."
  - "Use Python `requests` for RESTCONF and `ncclient` for NETCONF."
  - "Parse RESTCONF JSON and NETCONF XML into Python data structures."
  - "Extract comparable device facts (e.g., hostname, model, version, interface info)."
  - "Generate a human-readable report using f-strings, saved to the repo."
  - "Log clear, deterministic markers for autograding and troubleshooting."

# PREREQUISITES
python_version: "3.11"
accounts: ["GitHub"]
devices: ["Cisco DevNet Always-On Catalyst 8000v (RESTCONF + NETCONF)"]

prereq:
  - "Intermediate Python: functions, modules, exceptions, and logging."
  - "Basics of HTTP headers and authentication."
  - "Familiarity with XML/JSON and their Python libraries."
  - "GitHub Classroom workflow (clone, commit, push, PR)."
  - "Cisco DevNet sandbox credentials and device reachability."

# OVERVIEW
overview: >
  You will query a Catalyst 8k device via both RESTCONF (HTTP/JSON) and NETCONF (SSH/XML).
  For RESTCONF, use Python `requests` and proper YANG/JSON Accept headers; for NETCONF, use
  `ncclient` and standard RPCs. Make at least two calls per interface (2+ RESTCONF endpoints
  and 2+ NETCONF RPCs), parse outputs into Python, then craft a concise f-string report that
  compares findings (e.g., hostname, platform/model, version, and one interface/oper state).
  Save raw artifacts under `data/`, log autograder markers to `logs/lab5.log`, and submit a PR.

# SETUP
before_you_begin: >
  Confirm sandbox host/IP, RESTCONF port (often 443) and NETCONF port (830). Open the dev container,
  verify `requests`, `ncclient`, and `xmltodict` import successfully. Ensure you can write to `data/`
  and `logs/`.

# RESOURCES
resources:
  - { title: "Cisco DevNet Sandboxes (Catalyst 8k/IOS-XE)", url: "https://developer.cisco.com/site/sandbox/" }
  - { title: "RESTCONF — RFC 8040 (concepts)", url: "https://www.rfc-editor.org/rfc/rfc8040" }
  - { title: "NETCONF — RFC 6241 (concepts)", url: "https://www.rfc-editor.org/rfc/rfc6241" }
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "ncclient (Python)", url: "https://ncclient.readthedocs.io/" }
  - { title: "xmltodict", url: "https://github.com/martinblech/xmltodict" }

# DELIVERABLES
deliverables:
  - "`src/restconf_queries.py` — performs ≥2 RESTCONF GETs, saves raw JSON, logs markers."
  - "`src/netconf_queries.py` — performs ≥2 NETCONF RPCs, saves raw XML, logs markers."
  - "`src/report.py` (or integrate into one script) — parses saved artifacts and writes `data/reports/lab5_report.txt` using f-strings."
  - "`data/restconf_*.json` and `data/netconf_*.xml` raw outputs."
  - "`data/reports/lab5_report.txt` summary comparing key facts."
  - "`logs/lab5.log` with all required markers."
  - "Pull request open to `main` with all artifacts committed."

# STEPS
steps:
  - title: "Clone the Repository"
    goal: "Get the starter locally."
    actions: |
      Clone your Classroom repo and `cd` into it. Create `src/`, `data/raw/`, `data/reports/`, and `logs/` if missing.
      Initialize the lab log: `echo 'LAB5_START' >> logs/lab5.log`
    done_when: |
      - Folders exist and `LAB5_START` appears in `logs/lab5.log`.
    log_marker: "LAB5_START"

  - title: "Open Dev Container"
    goal: "Standardize the toolchain."
    actions: |
      Reopen in container. Verify imports:
        - `python -c "import requests, ncclient, xmltodict; print('OK')"`
      Append `[STEP 2] Dev Container Started` and `PKG_OK: requests`, `PKG_OK: ncclient` to the log.
    done_when: |
      - Python 3.11+ confirmed; packages import cleanly.
      - Log includes the markers.
    log_marker: "[STEP 2] Dev Container Started, PKG_OK: requests, PKG_OK: ncclient"

  - title: "RESTCONF — make ≥2 GET requests"
    goal: "Retrieve JSON via RESTCONF using correct headers."
    actions: |
      In `src/restconf_queries.py`:
        - Configure base URL (e.g., `https://<host>/restconf/data/`) and basic auth.
        - Set headers e.g., `{'Accept': 'application/yang-data+json'}`.
        - Choose ≥2 endpoints (examples to consider: system/hostname, platform, interfaces summary/oper status).
        - Use `requests.get(..., timeout=10, verify=False)` for sandbox; handle HTTP errors with try/except.
        - Save each response to `data/restconf_<name>.json`.
        - Log `CONNECT_OK: RESTCONF` once and `RESTCONF_REQ_OK:<name>` per successful endpoint; on failure, `RESTCONF_REQ_FAIL:<name>`.
        - Log `RAW_SAVED=restconf_<name>.json` after writing files.
    done_when: |
      - At least two `RESTCONF_REQ_OK:*` appear and raw JSON files exist.
    log_marker: "CONNECT_OK: RESTCONF, RESTCONF_REQ_OK, RAW_SAVED"

  - title: "NETCONF — make ≥2 RPCs"
    goal: "Retrieve XML via NETCONF with ncclient."
    actions: |
      In `src/netconf_queries.py`:
        - Use `manager.connect(host=..., port=830, username=..., password=..., hostkey_verify=False, timeout=10)`.
        - Log `CONNECT_OK: NETCONF` on successful session.
        - Issue ≥2 RPCs (e.g., get system/platform info, get interfaces-state). Use appropriate filters.
        - Save each RPC reply XML to `data/netconf_<name>.xml`.
        - Log `NETCONF_RPC_OK:<name>` per successful RPC; on failure, `NETCONF_RPC_FAIL:<name>`.
        - Log `RAW_SAVED=netconf_<name>.xml` after writing files.
    done_when: |
      - At least two `NETCONF_RPC_OK:*` appear and raw XML files exist.
    log_marker: "CONNECT_OK: NETCONF, NETCONF_RPC_OK, RAW_SAVED"

  - title: "Parse artifacts & build f-string report"
    goal: "Normalize JSON/XML and print a concise comparison."
    actions: |
      In `src/report.py` (or inside one of your scripts):
        - Load `data/restconf_*.json` with `json`.
        - Load `data/netconf_*.xml` with `xmltodict` (or `minidom`), convert to Python dicts.
        - Extract comparable fields: hostname, model/platform, version, and one interface count/oper-state metric.
        - Log `PARSE_JSON_OK:<name>` and `PARSE_XML_OK:<name>` when extraction succeeds.
        - Compose an f-string report summarizing both interfaces’ results and any differences.
        - Save report to `data/reports/lab5_report.txt` and log `REPORT_SAVED=lab5_report.txt`.
    done_when: |
      - `data/reports/lab5_report.txt` exists and includes values from both RESTCONF and NETCONF.
    log_marker: "PARSE_JSON_OK, PARSE_XML_OK, REPORT_SAVED=lab5_report.txt"

  - title: "Finalize & Submit"
    goal: "Ensure logs and artifacts are complete; open PR."
    actions: |
      Review `logs/lab5.log` for all required markers. Append `LAB5_END`.
      Commit and push all changes. Open a pull request targeting `main`.
    done_when: |
      - PR open; artifacts present and markers complete.
    log_marker: "LAB5_END"

# FAQ + TROUBLESHOOTING
faq:
  - q: "RESTCONF returned HTML, not JSON."
    a: "Set `Accept: application/yang-data+json` and use the exact RESTCONF path."
  - q: "NETCONF keeps failing to connect."
    a: "Use port 830, correct credentials, and `hostkey_verify=False` for the sandbox."
  - q: "Do I need YANG files locally?"
    a: "Not for these read-only queries; you just need correct paths/RPCs that align with YANG models."

tips:
  - title: "Timeouts"
    symptom: "Long waits or hang on calls."
    fix: "Set `timeout=10` and catch `requests.Timeout` or ncclient timeouts."
  - title: "File paths"
    symptom: "Nothing saved under `data/`."
    fix: "Create directories and use repo-relative paths; check write permissions."
  - title: "Markers missing"
    symptom: "Autograder shows missing tokens."
    fix: "Log exact strings from the Autograder section; don’t improvise marker text."

# GRADING
grading:
  total_points: 75
  rows:
    - { step: "Step 2", requirement: "Dev container started; packages verified", points: 5 }
    - { step: "RESTCONF", requirement: "≥2 RESTCONF endpoints succeed (`RESTCONF_REQ_OK:*`, `CONNECT_OK: RESTCONF`)", points: 12 }
    - { step: "NETCONF", requirement: "≥2 NETCONF RPCs succeed (`NETCONF_RPC_OK:*`, `CONNECT_OK: NETCONF`)", points: 12 }
    - { step: "Parsing", requirement: "JSON and XML parsed; fields extracted (`PARSE_JSON_OK:*`, `PARSE_XML_OK:*`)", points: 12 }
    - { step: "Report", requirement: "F-string report generated and saved (`REPORT_SAVED=lab5_report.txt`)", points: 12 }
    - { step: "Artifacts", requirement: "Raw files saved under `data/` with `RAW_SAVED=*` markers", points: 7 }
    - { step: "Error handling & logging", requirement: "Handled exceptions; consistent logging", points: 5 }
    - { step: "Submission", requirement: "PR open; `LAB5_START` and `LAB5_END` present", points: 10 }

# AUTOGRADING
autograder:
  log_path: "logs/lab5.log"
  required_markers:
    - "LAB5_START"
    - "[STEP 2] Dev Container Started"
    - "PKG_OK: requests"
    - "PKG_OK: ncclient"
    - "CONNECT_OK: RESTCONF"
    - "CONNECT_OK: NETCONF"
    - "RESTCONF_REQ_OK"
    - "NETCONF_RPC_OK"
    - "RAW_SAVED"
    - "PARSE_JSON_OK"
    - "PARSE_XML_OK"
    - "REPORT_SAVED=lab5_report.txt"
    - "LAB5_END"
  optional_markers:
    - "RESTCONF_REQ_FAIL"
    - "NETCONF_RPC_FAIL"

# SUBMISSION CHECKLIST
submission_checklist:
  - "`src/restconf_queries.py` and `src/netconf_queries.py` run without unhandled exceptions."
  - "`data/restconf_*.json` and `data/netconf_*.xml` exist and are populated."
  - "`data/reports/lab5_report.txt` compares fields from both interfaces."
  - "`logs/lab5.log` contains all required markers."
  - "Pull request open before deadline."

license: "© 2025 Sheldon Swanson — Classroom use."