# ==========================================
# Course: Software Defined Networking
# Module: RESTCONF vs NETCONF on Catalyst 8k
# Purpose: Hands on activity for interacting with network device APIs
# Filename: lab.yml
# Author: Sheldon Swanson
# Version: 1.0
# Created: 10/2025
# Updated: 10/2025
# Notes: Parsers ignore these comments.
# ==========================================
title: "Lab 5 — RESTCONF vs NETCONF on Catalyst 8k"
course: "Software Defined Networking"
module: "Network Automation Fundamentals"
lab_number: 5
time_estimate: "1.5–2 hours"
#====================================================
#   ____  _____    _    ____  __  __ _____
#  |  _ \| ____|  / \  |  _ \|  \/  | ____|
#  | |_) |  _|   / _ \ | | | | |\/| |  _|
#  |  _ <| |___ / ___ \| |_| | |  | | |___
#  |_| \_\_____/_/   \_\____/|_|  |_|_____|
#====================================================

repo_tree:
  enabled: true
  max_depth: 3
  ignore:
    - ".git"
    - ".github"
    - "_template"
    - "_render"
    - "__pycache__"
    - ".venv"
    - "venv"
    - "node_modules"
    - ".vscode"
    - ".idea"
    - "*.pyc"
    - "logs"
    - "screens"

readme_topic:
  - title: "Introduction to Network Device APIs"
    content: |
      Modern network devices expose programmable interfaces via RESTCONF and NETCONF, allowing
      automation tools to interact with device configurations and state data. This lab explores
      both protocols on a Cisco Catalyst 8000v device, comparing their usage and outputs.

  - title: "What is RESTCONF?"
    content: |
      RESTCONF is a REST-like protocol that provides a programmatic interface for accessing
      data defined in YANG, using HTTP methods. It typically returns data in JSON formats. RESTCONF
      is stateless and leverages standard HTTP features like authentication, caching, and error handling. You
      will use Python's `requests` library to interact with RESTCONF endpoints but can also use tools like Postman or curl.

      RESTCONF is defined in RFC 8040 and listens on HTTP/HTTPS ports (often 443). To enable RESTCONF on a Cisco device,
      you typically use the `restconf` command in global configuration mode as shown below:

    code_block:
      language: "bash"
      code: |
        router(config)# restconf
        router(config)# end
    code_notes: >
      Notes about the code block example.

  - title: "What is NETCONF?"
    content: |
      NETCONF is a network management protocol that provides mechanisms to install, manipulate,
      and delete the configuration of network devices. It uses XML for data encoding and operates
      over SSH. NETCONF is stateful and supports transactions, making it suitable for complex
      configuration tasks. You will use Python's `ncclient` library to interact with NETCONF, but
      tools like `netconf-console` can also be used.

      NETCONF is defined in RFC 6241 and typically listens on port 830. To enable NETCONF on a Cisco device,
      you usually need to ensure SSH is enabled and the device is configured to accept NETCONF sessions.
      On many Cisco devices, NETCONF is enabled by default when SSH is active. However, if you need to explicitly
      enable it, you can use the following commands:

    code_block:
      language: "bash"
      code: |
        router(config)# netconf-yang
        router(config)# end

  - title: "Comparing RESTCONF and NETCONF"
    content: |
      Both RESTCONF and NETCONF are powerful protocols for network device management, each with its
      own strengths. RESTCONF's use of HTTP and JSON makes it more accessible for web developers
      and easier to integrate with modern web services. In contrast, NETCONF's XML-based approach
      and support for transactions make it more suitable for complex configuration tasks in traditional
      network management scenarios.

      In this lab, you will interact with both protocols on a Cisco Catalyst 8000v device to retrieve
      system information, compare the outputs, and understand how YANG models influence both interfaces.

      RESTCONF is more suitable for web-based applications and simpler tasks, while NETCONF is often preferred for
      complex configurations and environments where transactional integrity is crucial. Device telemetry streaming
      is another area where NETCONF excels, as it can efficiently handle large volumes of data and provide real-time updates.

  - title: "What is YANG?"
    content: |
      YANG is a data modeling language used to define the structure of data that can be managed
      by network devices. It provides a way to model configuration and state data in a hierarchical
      manner, making it easier to understand and manipulate. YANG models are used by both RESTCONF
      and NETCONF to define the data that can be accessed or modified.

      In RESTCONF, YANG models are typically exposed as RESTful APIs, allowing clients to interact
      with the data using standard HTTP methods. In NETCONF, YANG models are used to define the
      XML-based RPC messages that are exchanged between clients and devices.

      Understanding YANG is crucial for working with both RESTCONF and NETCONF, as it provides
      the foundation for the data structures and operations that these protocols support.

      An example of YANG model snippet for system information might look like this:

    code_block:
      language: "yang"
      code: |
        module system {
          namespace "http://example.com/system";
          prefix sys;

          container system {
            leaf hostname {
              type string;
            }
            leaf version {
              type string;
            }
          }
        }
    code_notes: |
      This YANG model defines a `system` container with `hostname` and `version` leaves, which can be accessed via both RESTCONF and NETCONF 
      interfaces by referencing the appropriate paths or RPCs.  You can build the paths for RESTCONF based on the YANG model structure, and 
      for NETCONF, you can construct RPCs that correspond to the defined data nodes. To construct the RESTCONF path for the `system` container, you would typically use a URL like:

      `https://<device-ip>/restconf/data/system:system`

      To construct a NETCONF RPC to retrieve the same information, you would create an XML payload like:

      ```xml
      <rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
        <get>
          <filter>
            <system xmlns="http://example.com/system">
              <hostname/>
              <version/>
            </system>
          </filter>
        </get>
      </rpc>
      ```

  - title: "Cisco Catalyst 8k API Docs"
    content: |
      Cisco provides comprehensive API documentation for the Catalyst 8000 series, including
      RESTCONF and NETCONF interfaces. You can find the documentation at the following link:

      [Cisco Catalyst 8000 Series API Documentation](https://developer.cisco.com/docs/catalyst-8000/)

      This documentation includes details on available YANG models, RESTCONF endpoints, and
      NETCONF RPCs, along with examples and usage guidelines.

      This documentation is an essential resource for understanding how to interact with the
      Catalyst 8000 series devices using their APIs.

  - title: "Creating a RESTCONF Request with Python `requests`"
    content: |
      To create a RESTCONF request using Python's `requests` library, you need to set up the
      appropriate headers, authentication, and the URL for the RESTCONF endpoint. Below is an
      example of how to perform a GET request to retrieve system information from a Cisco
      Catalyst 8000v device.

    code_block:
      language: "python"
      code: |
        import requests
        from requests.auth import HTTPBasicAuth
        import json

        # Device details
        device_ip = "sandbox-iosxe-latest-1.cisco.com"
        restconf_port = 443
        username = "developer"
        password = "C1sco12345"

        # RESTCONF endpoint for system information
        url = f"https://{device_ip}:{restconf_port}/restconf/data/Cisco-IOS-XE-native:native/system"

        # Headers for RESTCONF
        headers = {
            "Accept": "application/yang-data+json",
            "Content-Type": "application/yang-data+json"
        }

        # Make the GET request
        response = requests.get(url, auth=HTTPBasicAuth(username, password), headers=headers, verify=False)

        # Check the response status
        if response.status_code == 200:
            system_info = response.json()
            print(json.dumps(system_info, indent=2))
        else:
            print(f"Error: {response.status_code} - {response.text}")
    code_notes: |
      In this example, replace `device_ip`, `username`, and `password` with your actual device
      details. The `verify=False` parameter is used to ignore SSL certificate warnings, which
      is common in lab environments. The response is checked for a successful status code (200),
      and if successful, the JSON response is printed in a formatted manner.

  - title: "Creating a NETCONF Request with Python `ncclient`"
    content: |
      To create a NETCONF request using Python's `ncclient` library, you need to establish
      a connection to the device and then send an RPC to retrieve the desired information.
      Below is an example of how to perform a GET request to retrieve system information
      from a Cisco Catalyst 8000v device.

    code_block:
      language: "python"
      code: |
        from ncclient import manager
        import xml.etree.ElementTree as ET

        # Device details
        device_ip = "sandbox-iosxe-latest-1.cisco.com"
        netconf_port = 830
        username = "developer"
        password = "C1sco12345"

        # NETCONF filter for system information
        filter = """
        <filter>
          <native xmlns="http://cisco.com/ns/yang/Cisco-IOS-XE-native">
            <system>
            </system>
          </native>
        </filter>
        """

        # Establish NETCONF connection
        with manager.connect(host=device_ip, port=netconf_port, username=username, password=password, hostkey_verify=False) as m:
            # Send the NETCONF RPC
            response = m.get(filter)

            # Parse and print the XML response
            xml_response = ET.fromstring(response.xml)
            print(ET.tostring(xml_response, encoding='unicode', method='xml'))
    code_notes: |
      In this example, replace `device_ip`, `username`, and `password` with your actual device
      details. The `hostkey_verify=False` parameter is used to ignore SSH host key verification,
      which is common in lab environments. The response is parsed as XML and printed in a
      readable format.

#========================================================================
#
#   ___ _   _ ____ _____ ____  _   _  ____ _____ ___ ___  _   _ ____
#  |_ _| \ | / ___|_   _|  _ \| | | |/ ___|_   _|_ _/ _ \| \ | / ___|
#   | ||  \| \___ \ | | | |_) | | | | |     | |  | | | | |  \| \___ \
#   | || |\  |___) || | |  _ <| |_| | |___  | |  | | |_| | |\  |___) |
#  |___|_| \_|____/ |_| |_| \_\\___/ \____| |_| |___\___/|_| \_|____/
#
#========================================================================

objectives:
  - "Read Catalyst 8k API docs and identify valid RESTCONF endpoints."
  - "Use Python `requests` to call RESTCONF and retrieve system/platform details."
  - "Explain the role of YANG models for device data."
  - "Use Python `ncclient` to call NETCONF for the same info."
  - "Compare RESTCONF (HTTP/JSON) vs NETCONF (SSH/XML/RPC) outputs."
  - "Log clearly and save raw artifacts + a human-readable report."

python_version: "3.11"
accounts: ["GitHub"]
devices: ["Cisco DevNet Always-On Sandbox: Catalyst 8000v (RESTCONF + NETCONF)"]

overview: >
  Work directly with network device APIs. First, call a Catalyst 8k RESTCONF endpoint with
  Python `requests` to fetch system/platform information (e.g., model/version). Then perform
  the equivalent query with NETCONF via `ncclient`. Save raw JSON/XML, compare results, and
  generate a short report. Along the way, note where YANG models shape both interfaces.

before_you_begin: >
  Open the dev container, confirm outbound network access, and note the sandbox hostname/IP plus
  RESTCONF and NETCONF ports from DevNet. Create `logs/`, `data/raw/`, and `data/reports/` if missing.

resources:
  - { title: "Cisco DevNet Always-On Sandbox (IOS-XE/C8Kv)", url: "https://developer.cisco.com/site/sandbox/" }
  - { title: "Requests (Python)", url: "https://requests.readthedocs.io/en/latest/" }
  - { title: "ncclient (Python NETCONF)", url: "https://ncclient.readthedocs.io/" }
  - { title: "RESTCONF (concepts)", url: "https://www.rfc-editor.org/rfc/rfc8040" }
  - { title: "NETCONF (concepts)", url: "https://www.rfc-editor.org/rfc/rfc6241" }

faq:
  - q: "RESTCONF returns HTML instead of JSON—why?"
    a: "Set an Accept header for YANG/JSON (e.g., `application/yang-data+json`) and use the exact RESTCONF path."
  - q: "NETCONF fails with SSH/EOF errors."
    a: "Use the NETCONF port (often 830), correct credentials, and `hostkey_verify=False` for the sandbox."
  - q: "Do I need YANG files locally?"
    a: "Not for these read-only queries; you just need the correct endpoint/RPC names that map to YANG."

deliverables:
  readme_summary: "Standardized README with goals, overview, resources, grading, and tips."
  instructions_summary: "Stepwise INSTRUCTIONS for RESTCONF + NETCONF + compare; logs + artifacts saved."
  files:
    src:
      - "src/restconf_system_info.py"
      - "src/netconf_system_info.py"
      - "src/compare_outputs.py"
    data:
      - "data/raw/restconf_system.json"
      - "data/raw/netconf_system.xml"
      - "data/reports/system_report.txt"
    logs:
      - "logs/restconf_system_info.log"
      - "logs/netconf_system_info.log"
      - "logs/compare_outputs.log"
      - "logs/devcontainer_health.log"
      - "logs/DEVCONTAINER_STATUS.txt"

grading:
  total_points: 75
  rows:
    - { step: "1", requirement: "Repo cloned and structure verified", points: 5 }
    - { step: "2", requirement: "Dev container opened; dependencies OK", points: 5 }
    - { step: "3", requirement: "Sandbox reachable (ping/ports)", points: 5 }
    - { step: "4", requirement: "API docs reviewed; endpoint/RPC chosen", points: 5 }
    - { step: "5", requirement: "RESTCONF script runs, retrieves JSON", points: 10 }
    - { step: "6", requirement: "RESTCONF raw saved + log markers present", points: 5 }
    - { step: "7", requirement: "NETCONF script runs, retrieves XML", points: 10 }
    - { step: "8", requirement: "NETCONF raw saved + log markers present", points: 5 }
    - { step: "9", requirement: "Compare script parses both and matches key fields", points: 10 }
    - { step: "10", requirement: "Final report generated in `data/reports/system_report.txt`", points: 10 }
    - { step: "10b", requirement: "All deliverables pushed; logs complete", points: 5 }

tips:
  - title: "Got HTML from RESTCONF"
    symptom: "Device responded with a web page"
    fix: "Add `headers={'Accept': 'application/yang-data+json'}` and verify the exact path against docs."
  - title: "Requests hangs"
    symptom: "No response on RESTCONF"
    fix: "Pass `timeout=10` and handle `requests.Timeout`."
  - title: "Messy XML"
    symptom: "NETCONF output hard to read"
    fix: "Use `xmltodict` or `xml.dom.minidom` to pretty-print."
  - title: "File not found"
    symptom: "Nothing written under `data/`"
    fix: "Create directories and use correct relative paths from repo root."
  - title: "No points despite success"
    symptom: "Autograder says missing markers"
    fix: "Ensure required log lines exactly match the tokens below."

autograder:
  log_path: "logs/*.log"
  required_markers:
    - "LAB5_START"
    - "[STEP 2] Dev Container Started"
    - "DEVCONTAINER_OK"
    - "PKG_OK: requests"
    - "PKG_OK: ncclient"
    - "CONNECT_OK: RESTCONF"
    - "CONNECT_OK: NETCONF"
    - "CMD=GET system"
    - "RPC=system info"
    - "RAW_SAVED=restconf_system.json"
    - "RAW_SAVED=netconf_system.xml"
    - "PARSE_JSON_OK"
    - "PARSE_XML_OK"
    - "COMPARE_OK"
    - "REPORT_SAVED=system_report.txt"
    - "LAB5_HEALTH_START"
    - "DNS_OK"
    - "NET_OK"
    - "HEALTH_OVERALL=True"
    - "LAB5_HEALTH_END"
    - "LAB5_END"

submission_checklist:
  - "All three scripts exist in `src/` and run without tracebacks."
  - "`data/raw/restconf_system.json` and `data/raw/netconf_system.xml` are present and non-empty."
  - "`data/reports/system_report.txt` summarizes hostname, model, and version with method labels."
  - "`logs/restconf_system_info.log` includes RESTCONF CONNECT_OK, CMD=GET, and RAW_SAVED markers."
  - "`logs/netconf_system_info.log` includes NETCONF CONNECT_OK, RPC marker, and RAW_SAVED markers."
  - "`logs/compare_outputs.log` shows PARSE_JSON_OK, PARSE_XML_OK, and COMPARE_OK."
  - "`logs/devcontainer_health.log` shows DNS_OK, NET_OK, HEALTH_OVERALL=True."
  - "`logs/DEVCONTAINER_STATUS.txt` shows Overall status: READY."

steps:
  - title: "Clone the Repository"
    goal: "Get your Classroom repo locally."
    actions: |
      Clone and `cd` into the repo. Confirm `src/`, `data/`, and `logs/` exist (create if needed).
    done_when: "You see the three folders; Git is tracking changes."
    log_marker: "LAB5_START"

  - title: "Open a Dev Container"
    goal: "Use the standardized environment."
    actions: |
      Reopen in container; wait for dependencies. Verify `python --version`. Write a banner to `logs/DEVCONTAINER_STATUS.txt`.
    done_when: "You log `[STEP 2] Dev Container Started` and `DEVCONTAINER_OK`."
    log_marker: "[STEP 2] Dev Container Started, DEVCONTAINER_OK"

  - title: "Confirm Sandbox Details"
    goal: "Identify target host/ports and basic reachability."
    actions: |
      From container, ping the sandbox host and note RESTCONF and NETCONF ports from DevNet page.
    done_when: "You log sandbox reachability in `logs/devcontainer_health.log`."
    log_marker: "LAB5_HEALTH_START, DNS_OK, NET_OK, LAB5_HEALTH_END"

  - title: "Review API Docs"
    goal: "Pick the exact RESTCONF endpoint and NETCONF RPC for system/platform info."
    actions: "Open vendor docs; record path/RPC and any auth/header requirements."
    done_when: "You log a line stating the chosen endpoint/RPC."
    log_marker: "DOCS_REVIEWED"

  - title: "RESTCONF — system/platform info"
    goal: "Fetch JSON with Python `requests`."
    actions: |
      Implement `src/restconf_system_info.py` using HTTP Basic Auth and an Accept header for YANG/JSON.
      Save raw to `data/raw/restconf_system.json`.
    done_when: "Status shows OK; JSON saved."
    log_marker: "CONNECT_OK: RESTCONF, CMD=GET system, RAW_SAVED=restconf_system.json, PARSE_JSON_OK"

  - title: "NETCONF — same info"
    goal: "Fetch XML with `ncclient`."
    actions: |
      Implement `src/netconf_system_info.py` connecting to NETCONF port; issue the RPC for system/platform info.
      Save raw to `data/raw/netconf_system.xml`.
    done_when: "Session succeeds; XML saved."
    log_marker: "CONNECT_OK: NETCONF, RPC=system info, RAW_SAVED=netconf_system.xml, PARSE_XML_OK"

  - title: "Compare outputs"
    goal: "Verify fields match and note differences."
    actions: |
      Implement `src/compare_outputs.py` to load both artifacts, extract model/version (and hostname if available),
      print/compare, and append `data/reports/system_report.txt`.
    done_when: "Comparison shown; report updated."
    log_marker: "COMPARE_OK, REPORT_SAVED=system_report.txt"

  - title: "Commit, push, submit"
    goal: "Hand in cleanly."
    actions: "Commit artifacts and logs; push; open a PR to `main`."
    done_when: "PR opens and CI is green."
    log_marker: "LAB5_END"

license: "© 2025 Your Name — Classroom use."

